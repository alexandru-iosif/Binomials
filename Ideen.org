* Handling the git-beast:
** The experimental branch is the one we are working on
** The master branch is kind of a release branch that tracks public versions
* To make the cellular decomposition faster
** Can we guess a priori some monomial primes ?
** The first component is toric -> implement special handling
* Dividing out monomials that are units:
  > | c-1 ad-1 b^2-1 a^2-1 abe-a |
    c-1  d-a b^2-1 a^2-1  e-b

Here I have used that, modulo the ideal in question, a = a^{-1} 
is a unit, and b = b^{-1} is, too.  This ideal is precisely the 
first ideal
* Compute all "associated lattices"
* Use thm 8.3:
If the radical of a binomial ideal is prime and does not contain any
of the variables, then the cellular decomposition is primary
* Dans Ideas on Parallelization
** See Mailinglist for unclobbered version
M2 doesn't use multiple threads otherwise yet.  The "fork" function of
M2
implements the "fork" system call, but there is also "run" as well as
the
possibility of opening a file whose name is a command prefixed with
"!".  You
can use "wait" to wait for various processes to finish their assigned
tasks.

Here is some demo code that does that.  You give it a list of
hostnames on
which to run M2, and a list of command names to use for starting M2 on
those
hosts.  It starts up that many M2's running on those hosts, giving
each one a
different random number.  The idea is that those instances of M2 would
do
different tasks, in a real application.  In this case, each instance
of M2
sleeps a random number of seconds, prints a random polynomial, and
exits.

command = seed -> concatenate("setRandomSeed ",toString seed,"; sleep
random 10 ; R = ZZ/101[x,y,z]; print toExternalString random_3 R")
hostnames = splice { 4 : "gallium" , "habanero" }
M2names   = splice { 4 : "M2.dev",   "M2" }
absorb = (hostnum,retval) -> (
     -- this is a user provided routine that absorbs one line of
     output from a process
     stderr << "-- process " << hostnum << " on host " <<
     hostnames#hostnum << " produced " << retval << endl;
     )
newguy = (hostnum,seed) -> openIn concatenate( "!ssh ",
hostnames#hostnum, " ", M2names#hostnum, " --silent -e '\"", command
seed, "; exit 0\"'" )
monitor = () -> (
     files = new MutableList from apply(#hostnames, hostnum ->
     newguy(hostnum, random 1000000));
     outputs = new MutableList from toList ( #hostnames : "" );
     while true do (
       scan(wait files, i -> (
           ret := read files#i;
	       outputs#i = concatenate(outputs#i, ret);
	           t := separate("\n", outputs#i);
		   scan(#t-1, j -> absorb(i,t#j));
		   outputs#i = t#-1;
		   ));
		   scan(#files, i -> (
		   if atEndOfFile files#i then (
		   close files#i;
		   files#i = newguy(i, random
		   1000000);
		   )))))
* For Imn compute the monomials, clarify the combinatorial structure !
* We should have a function which coerces to a common field
** Here we should use memoize 
