* Handling the git-beast:
** The experimental branch is the one we are working on
** The master branch is kind of a release branch that tracks public versions
* Do a real competition against Singular
* To make the cellular decomposition faster
** Can we guess a priori some monomial primes ?
** The first component is toric -> implement special handling
* Dividing out monomials that are units:
  > | c-1 ad-1 b^2-1 a^2-1 abe-a |
    c-1  d-a b^2-1 a^2-1  e-b

Here I have used that, modulo the ideal in question, a = a^{-1} 
is a unit, and b = b^{-1} is, too.  This ideal is precisely the 
first ideal
* Compute all "associated lattices"
* Use thm 8.3:
If the radical of a binomial ideal is prime and does not contain any
of the variables, then the cellular decomposition is primary
* Dans Ideas on Parallelization
** See Mailinglist for unclobbered version
M2 doesn't use multiple threads otherwise yet.  The "fork" function of
M2
implements the "fork" system call, but there is also "run" as well as
the
possibility of opening a file whose name is a command prefixed with
"!".  You
can use "wait" to wait for various processes to finish their assigned
tasks.

Here is some demo code that does that.  You give it a list of
hostnames on
which to run M2, and a list of command names to use for starting M2 on
those
hosts.  It starts up that many M2's running on those hosts, giving
each one a
different random number.  The idea is that those instances of M2 would
do
different tasks, in a real application.  In this case, each instance
of M2
sleeps a random number of seconds, prints a random polynomial, and
exits.

command = seed -> concatenate("setRandomSeed ",toString seed,"; sleep
random 10 ; R = ZZ/101[x,y,z]; print toExternalString random_3 R")
hostnames = splice { 4 : "gallium" , "habanero" }
M2names   = splice { 4 : "M2.dev",   "M2" }
absorb = (hostnum,retval) -> (
     -- this is a user provided routine that absorbs one line of
     output from a process
     stderr << "-- process " << hostnum << " on host " <<
     hostnames#hostnum << " produced " << retval << endl;
     )
newguy = (hostnum,seed) -> openIn concatenate( "!ssh ",
hostnames#hostnum, " ", M2names#hostnum, " --silent -e '\"", command
seed, "; exit 0\"'" )
monitor = () -> (
     files = new MutableList from apply(#hostnames, hostnum ->
     newguy(hostnum, random 1000000));
     outputs = new MutableList from toList ( #hostnames : "" );
     while true do (
       scan(wait files, i -> (
           ret := read files#i;
	       outputs#i = concatenate(outputs#i, ret);
	           t := separate("\n", outputs#i);
		   scan(#t-1, j -> absorb(i,t#j));
		   outputs#i = t#-1;
		   ));
		   scan(#files, i -> (
		   if atEndOfFile files#i then (
		   close files#i;
		   files#i = newguy(i, random
		   1000000);
		   )))))
* For Imn compute the monomials, clarify the combinatorial structure !
* The toric component should be treated seperately.
* TODO TODOLIST [2/8]
** TODO Study the Cellularity of binomial Quotients.  
Currently, discovered in the BPD of component #20 of the ideal of 2x2 adjacent minors of a 5x5 matrix, it seems as if
the operation binomial Quotient that is applied in the course of computing the minimal primary component may not
preserve being cellular. Then Algorithm 9.6 is not well defined as it calls itself recursively while not preserving the
necessary condition of the input being cellular.
** TODO Remove redundant does not work properly as it does not check partial intersections for being contained in other stuff :(
** DONE Make "removeRedundant" public
   CLOSED: [2009-12-07 Mon 12:23]   
** TODO Improve associated Primes to prune the list of monomials ! It is a poset !!
In particular it should construct the partial order on the list and do some magic with Posets.m2
Partial solution: Use a Hash to avoid repeating computations.
** TODO Maybe we should also use memoize when creating new instances of polynomial rings to avoid xcessive garbage collections
** TODO Improve binomialRadical of a general I
We should simply run the cellular decomposition of the radical. Then take radicals of these cellular ideals and do
something with them 
** TODO Make a type BinomialIdeal true
** DONE BUG: Associated Primes von cd#11 in Zellzerlegung von 2adj5 hat doppelte Elemente!
   This is a 'feature' of the unique function in M2. It uses hashes and therefore two ideals with 
   different generating sets are distinct. Fixed by computing mingens in associated primes
   CLOSED: [2010-01-24 Sun 23:11]
